import CapacityError from "./capacity_error.nx"
import { log2 } from "../math.nx"

# A FIFO queue.
#
# ```
# final queue = Queue<Int32>()
# queue.push(1)
# queue.push(2)
# assert(queue.shift() == 1)
# ```
#
export default class Queue<T> : [
  Pushable<T>,
  Shiftable<T>
] {
  getter capacity, size : USize = 0

  # Would be accessible on `another : Queue`,
  # but only from within a `~ Queue` method.
  protected getter pointer : T*

  # Would only be accessible on `this`.
  # private let pointer : T*

  # TODO: An arg is `final` by default.
  static self(let capacity : USize = 0) -> {
    if (capacity > 0) {
      return self({
        pointer: Memory::alloca<T>(capacity),
        capacity: log2(capacity).ceil(),
      })
    } else {
      return self({
        pointer: unsafe! uninitialized T*,
      })
    }
  }

  # TODO: `queue~Pushable` requires `Pushable` to be imported,
  # that's why can't use `self::Pushable`.
  impl self~Pushable.push(value) -> {
    # TODO: Get rid of special assignment (`this.size += 1`), as it's too complex.
    this.resize!(this.size + 1)

    unsafe! @incrc(value)
    unsafe! this.pointer[this.size - 1] = value
  }

  # Merge itself with _another_ queue.
  def merge!(another : self) -> (void){
    this.resize!(this.size + another.size)

    unsafe! Memory::copy(
      from: another.pointer,
      to: this.pointer + this.size)
  }

  impl self~Shiftable.shift() -> {
    final value = this.shift?()
    if (!value) throw IndexError(index)
    else return value
  }

  impl self~Shiftable.shift?() -> {
    if (this.size == 0) then return void
    final value = this[this.size - 1]
    unsafe! @decrc(value)
    this.resize!(this.size -= 1)
    return value
  }

  reimpl eachfield(yield) -> {
    (0...this.size).each(i => yield(this[i]))
  }

  reimpl unsafe finalize() -> {
    this.eachfield(e => @decrc(e))
    Memory::free(this.pointer)
  }
}
